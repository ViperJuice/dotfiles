#!/bin/bash
# oc — OpenCode wrapper with per-repo XDG isolation
#
# Provides runtime isolation for concurrent multi-repo OpenCode usage by
# setting XDG_DATA_HOME and XDG_STATE_HOME per-repo, so each repo gets its
# own SQLite database, snapshots, and logs.
#
# Usage:
#   oc                   Launch TUI (isolated)
#   oc serve             Start backend (isolated, dynamic port)
#   oc run <msg>         Attach to running backend or start one, then run
#   oc audit             Run diagnostics
#   oc registry [cmd]    Manage running instances
#   oc cleanup           Prune stale repos, compact DBs
#   oc <anything>        Passthrough to opencode (isolated)

set -euo pipefail

REGISTRY_DIR="$HOME/.opencode/repos"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# ─── Debug logging ───────────────────────────────────────────────────────────
LOG_DIR="${HOME}/.cache/claude-dotfiles/logs"
debug_log() {
    if [[ -n "${CLAUDE_DOTFILES_DEBUG:-}" ]]; then
        mkdir -p "$LOG_DIR" 2>/dev/null
        echo "[$(date)] [oc] $*" >> "$LOG_DIR/opencode.log"
    fi
}

# ─── Repo identification ────────────────────────────────────────────────────

resolve_repo() {
    # Get git worktree root (not just .git directory)
    local worktree
    worktree=$(git rev-parse --show-toplevel 2>/dev/null) || {
        echo "Error: not inside a git repository" >&2
        exit 1
    }
    local real_path
    real_path=$(realpath "$worktree")
    local repo_id
    repo_id=$(echo -n "$real_path" | sha1sum | cut -c1-12)
    local repo_name
    repo_name=$(basename "$real_path")

    echo "$repo_id"$'\t'"$real_path"$'\t'"$repo_name"
}

# ─── Per-repo directory setup ────────────────────────────────────────────────

ensure_repo_dir() {
    local repo_id="$1" worktree="$2" name="$3"
    local repo_dir="$REGISTRY_DIR/$repo_id"

    mkdir -p "$repo_dir/data/opencode" "$repo_dir/state/opencode"

    # Write metadata (idempotent)
    echo "$name" > "$repo_dir/name"
    echo "$worktree" > "$repo_dir/worktree"

    echo "$repo_dir"
}

# ─── Shared auth (single auth.json across all repos) ────────────────────────

link_shared_auth() {
    local repo_dir="$1"
    local shared_auth="$HOME/.local/share/opencode/auth.json"
    local repo_auth="$repo_dir/data/opencode/auth.json"

    # Ensure shared auth directory exists
    mkdir -p "$(dirname "$shared_auth")" 2>/dev/null || true

    # If repo has a real auth file (not a symlink), merge it into shared
    if [[ -f "$repo_auth" && ! -L "$repo_auth" ]]; then
        if [[ ! -f "$shared_auth" ]]; then
            # No shared file yet — promote repo's auth directly
            cp "$repo_auth" "$shared_auth"
            chmod 600 "$shared_auth"
            debug_log "promoted repo auth to shared: $repo_auth → $shared_auth"
        else
            # Both exist — merge provider keys (keeps all providers, newer wins per-key)
            python3 -c "
import json, sys
shared = json.load(open(sys.argv[1]))
repo = json.load(open(sys.argv[2]))
for k, v in repo.items():
    if k not in shared:
        shared[k] = v
    elif v.get('expires', 0) > shared[k].get('expires', 0):
        shared[k] = v
json.dump(shared, open(sys.argv[1], 'w'), indent=2)
" "$shared_auth" "$repo_auth" 2>/dev/null && {
                chmod 600 "$shared_auth"
                debug_log "merged repo auth into shared: $repo_auth → $shared_auth"
            }
        fi
        rm "$repo_auth"
    fi

    # Create symlink (idempotent)
    if [[ ! -L "$repo_auth" ]]; then
        ln -sf "$shared_auth" "$repo_auth"
        debug_log "linked auth: $repo_auth → $shared_auth"
    fi
}

# ─── XDG export ──────────────────────────────────────────────────────────────

export_xdg() {
    local repo_dir="$1"
    export XDG_DATA_HOME="$repo_dir/data"
    export XDG_STATE_HOME="$repo_dir/state"
    debug_log "XDG_DATA_HOME=$XDG_DATA_HOME XDG_STATE_HOME=$XDG_STATE_HOME"
}

# ─── Write lock (flock-based) ────────────────────────────────────────────────

acquire_write_lock() {
    local repo_dir="$1"
    local lock_file="$repo_dir/write.lock"
    exec 9>"$lock_file"
    if ! flock -n 9; then
        echo "Error: another write session is active for this repo" >&2
        exit 1
    fi
    debug_log "acquired write lock: $lock_file"
}

release_write_lock() {
    flock -u 9 2>/dev/null || true
}

# ─── Backend management ─────────────────────────────────────────────────────

is_backend_healthy() {
    local endpoint="$1"
    # Quick health check via HTTP
    curl -sf --max-time 2 "${endpoint}/health" >/dev/null 2>&1 || \
    curl -sf --max-time 2 "$endpoint" >/dev/null 2>&1
}

ensure_running() {
    local repo_dir="$1"
    local pid_file="$repo_dir/pid"
    local port_file="$repo_dir/port"
    local endpoint_file="$repo_dir/endpoint"

    # Check existing backend
    if [[ -f "$pid_file" ]]; then
        local existing_pid
        existing_pid=$(cat "$pid_file")
        if kill -0 "$existing_pid" 2>/dev/null; then
            if [[ -f "$endpoint_file" ]]; then
                local existing_endpoint
                existing_endpoint=$(cat "$endpoint_file")
                debug_log "backend already running pid=$existing_pid endpoint=$existing_endpoint"
                echo "$existing_endpoint"
                return 0
            fi
        fi
        # Stale PID — clean up
        rm -f "$pid_file" "$port_file" "$endpoint_file"
        debug_log "cleaned stale pid=$existing_pid"
    fi

    # Start new backend (port 0 = let opencode pick a free port)
    debug_log "starting new backend in $repo_dir"

    local log_file="$repo_dir/serve.log"
    > "$log_file"
    opencode serve > "$log_file" 2>&1 &
    local new_pid=$!
    echo "$new_pid" > "$pid_file"
    debug_log "launched backend pid=$new_pid"

    # Wait for "listening on http://..." in log output (up to 30 seconds)
    local endpoint=""
    for _ in {1..60}; do
        sleep 0.5
        # Check if process is still alive
        if ! kill -0 "$new_pid" 2>/dev/null; then
            echo "Error: backend exited unexpectedly. Check $log_file" >&2
            cat "$log_file" >&2
            rm -f "$pid_file"
            exit 1
        fi
        # Parse: "opencode server listening on http://127.0.0.1:PORT"
        endpoint=$(grep -oP 'http://[0-9.:]+' "$log_file" 2>/dev/null | tail -1 || true)
        if [[ -n "$endpoint" ]]; then
            break
        fi
    done

    if [[ -z "$endpoint" ]]; then
        echo "Error: could not determine backend endpoint after 30s. Check $log_file" >&2
        kill "$new_pid" 2>/dev/null || true
        rm -f "$pid_file"
        exit 1
    fi

    local port
    port=$(echo "$endpoint" | grep -oP ':\K\d+$')
    echo "$port" > "$port_file"
    echo "$endpoint" > "$endpoint_file"
    debug_log "backend ready pid=$new_pid port=$port endpoint=$endpoint"

    # Start memory logging in background
    start_memory_logging "$repo_dir" "$new_pid" &

    echo "$endpoint"
}

# ─── Memory logging ─────────────────────────────────────────────────────────

start_memory_logging() {
    local repo_dir="$1" pid="$2"
    local mem_log="$repo_dir/memory.log"
    disown 2>/dev/null || true

    while kill -0 "$pid" 2>/dev/null; do
        local rss
        rss=$(ps -o rss= -p "$pid" 2>/dev/null || echo 0)
        if [[ "$rss" -gt 0 ]]; then
            echo "$(date -Iseconds) pid=$pid rss_kb=$rss" >> "$mem_log"
        fi
        sleep 300  # 5 minutes
    done
}

# ─── Command routing ────────────────────────────────────────────────────────

main() {
    local cmd="${1:-}"

    # Delegate to companion scripts (no repo context needed)
    case "$cmd" in
        audit)
            exec "$SCRIPT_DIR/oc-audit" "${@:2}"
            ;;
        registry)
            exec "$SCRIPT_DIR/oc-registry" "${@:2}"
            ;;
        cleanup)
            exec "$SCRIPT_DIR/oc-cleanup" "${@:2}"
            ;;
    esac

    # All other commands need repo context
    local repo_info repo_id worktree name
    repo_info=$(resolve_repo)
    IFS=$'\t' read -r repo_id worktree name <<< "$repo_info"

    local repo_dir
    repo_dir=$(ensure_repo_dir "$repo_id" "$worktree" "$name")
    link_shared_auth "$repo_dir"
    export_xdg "$repo_dir"

    debug_log "cmd=$cmd repo=$repo_id name=$name worktree=$worktree"

    case "$cmd" in
        "")
            # No args: launch TUI
            if [[ -n "${ZELLIJ:-}" ]]; then
                local pane_id="${ZELLIJ_PANE_ID:-}"
                local branch
                branch=$(git -C "$worktree" branch --show-current 2>/dev/null) || true
                local title="${name}${branch:+:$branch}"

                # Store session root for notification scripts
                local session_dir="${XDG_CACHE_HOME:-$HOME/.cache}/claude-dotfiles/pane-session"
                mkdir -p "$session_dir" 2>/dev/null || true
                echo "$worktree" > "$session_dir/${pane_id:-none}" 2>/dev/null || true

                # Set pane title (initial — may be overridden by exec/process detection)
                zellij action rename-pane -p "$pane_id" "$title" 2>/dev/null || true

                debug_log "zellij pane title='$title' session_root=$worktree"

                # Background: re-apply title after OpenCode initializes to defeat
                # Zellij's process-name-based title override (5 attempts over 10s)
                (
                    for _i in 1 2 3 4 5; do
                        sleep 2
                        zellij action rename-pane -p "$pane_id" "$title" 2>/dev/null || true
                    done
                ) &
                local enforcer_pid=$!
                disown "$enforcer_pid" 2>/dev/null || true

                # Run as child (not exec) so bash survives for post-exit cleanup
                local oc_rc=0
                opencode || oc_rc=$?

                # Clean up title enforcer
                kill "$enforcer_pid" 2>/dev/null || true

                # Restore pane title (branch may have changed during session)
                branch=$(git -C "$worktree" branch --show-current 2>/dev/null) || true
                title="${name}${branch:+:$branch}"
                zellij action rename-pane -p "$pane_id" "$title" 2>/dev/null || true
                debug_log "opencode exited rc=$oc_rc, restored title='$title'"

                exit "$oc_rc"
            else
                exec opencode
            fi
            ;;
        serve)
            # Start backend with isolation
            acquire_write_lock "$repo_dir"
            trap 'release_write_lock' EXIT

            local log_file="$repo_dir/serve.log"
            local pid_file="$repo_dir/pid"

            > "$log_file"
            opencode serve "${@:2}" > "$log_file" 2>&1 &
            local serve_pid=$!
            echo "$serve_pid" > "$pid_file"

            # Wait for "listening on http://..." in log (up to 30s)
            local endpoint=""
            for _ in {1..60}; do
                sleep 0.5
                if ! kill -0 "$serve_pid" 2>/dev/null; then
                    echo "Error: backend exited unexpectedly. Check $log_file" >&2
                    cat "$log_file" >&2
                    rm -f "$pid_file"
                    exit 1
                fi
                endpoint=$(grep -oP 'http://[0-9.:]+' "$log_file" 2>/dev/null | tail -1 || true)
                [[ -n "$endpoint" ]] && break
            done

            if [[ -n "$endpoint" ]]; then
                local port
                port=$(echo "$endpoint" | grep -oP ':\K\d+$')
                echo "$port" > "$repo_dir/port"
                echo "$endpoint" > "$repo_dir/endpoint"
                echo "Backend started: PID $serve_pid, port $port"
                echo "  Repo:     $name ($repo_id)"
                echo "  Endpoint: $endpoint"

                # Start memory logging
                start_memory_logging "$repo_dir" "$serve_pid" &
                disown 2>/dev/null || true
            else
                echo "Backend started: PID $serve_pid (port detection pending)"
                echo "  Check: $log_file"
            fi

            # Wait for backend (foreground — Ctrl+C stops it)
            wait "$serve_pid" 2>/dev/null || true
            ;;
        run)
            # Auto-attach to existing backend or start one
            if [[ $# -lt 2 ]]; then
                echo "Usage: oc run <message>" >&2
                exit 1
            fi
            local endpoint
            endpoint=$(ensure_running "$repo_dir")
            debug_log "run: attaching to $endpoint"
            exec opencode run --attach "$endpoint" "${@:2}"
            ;;
        *)
            # Passthrough to opencode with isolation
            exec opencode "$@"
            ;;
    esac
}

main "$@"
